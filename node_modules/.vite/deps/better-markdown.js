import "./chunk-PZ5AY32C.js";

// node_modules/better-markdown/dist/index.js
function customSyntaxPlugin(md) {
  function isInsideUrl(text, pos) {
    const lookBehind = text.substring(Math.max(0, pos - 100), pos);
    const urlPatterns = [
      /https?:\/\/[^\s]*$/,
      /ftp:\/\/[^\s]*$/,
      /www\.[^\s]*$/
    ];
    for (const pattern of urlPatterns) {
      if (pattern.test(lookBehind)) {
        return true;
      }
    }
    let parenDepth = 0;
    for (let i = pos - 1; i >= 0; i--) {
      if (lookBehind[lookBehind.length - (pos - i)] === ")") {
        parenDepth++;
      } else if (lookBehind[lookBehind.length - (pos - i)] === "(") {
        if (parenDepth === 0) {
          if (i > 0 && text[i - 1] === "]") {
            return true;
          }
          break;
        }
        parenDepth--;
      }
    }
    return false;
  }
  function createInlineRule(name, marker, tag, allowDouble = true, skipInUrls = false) {
    const singleChar = marker;
    const doubleChar = marker + marker;
    md.inline.ruler.before("emphasis", `${name}_single`, function(state, silent) {
      if (name === "italic_slash") console.log(`[DEBUG] italic_slash check at ${state.pos}: ${state.src.slice(state.pos, state.pos + 10)}`);
      const start = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {
        return false;
      }
      if (skipInUrls && isInsideUrl(state.src, start)) {
        return false;
      }
      if (start > 0) {
        const prevChar = state.src.charCodeAt(start - 1);
        if (prevChar >= 48 && prevChar <= 57 || // 0-9
        prevChar >= 65 && prevChar <= 90 || // A-Z
        prevChar >= 97 && prevChar <= 122) {
          return false;
        }
      }
      if (start + 1 < max && state.src.charCodeAt(start + 1) === 32) {
        return false;
      }
      let pos = start + 1;
      let foundClose = false;
      while (pos < max) {
        if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {
          if (pos + 1 < max && state.src.charCodeAt(pos + 1) === marker.charCodeAt(0)) {
            pos += 2;
            continue;
          }
          if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 32) {
            pos++;
            continue;
          }
          foundClose = true;
          break;
        }
        pos++;
      }
      if (!foundClose || pos === start + 1) {
        return false;
      }
      if (!silent) {
        const token_o = state.push(`${tag}_open`, tag, 1);
        token_o.markup = singleChar;
        const token_t = state.push("text", "", 0);
        token_t.content = state.src.slice(start + 1, pos);
        const token_c = state.push(`${tag}_close`, tag, -1);
        token_c.markup = singleChar;
      }
      state.pos = pos + 1;
      return true;
    });
    if (allowDouble) {
      md.inline.ruler.before("emphasis", `${name}_double`, function(state, silent) {
        const start = state.pos;
        const max = state.posMax;
        if (start + 1 >= max || state.src.charCodeAt(start) !== marker.charCodeAt(0) || state.src.charCodeAt(start + 1) !== marker.charCodeAt(0)) {
          return false;
        }
        if (start + 2 >= max || state.src.charCodeAt(start + 2) !== 32) {
          return false;
        }
        let pos = start + 3;
        let foundClose = false;
        while (pos + 2 < max) {
          if (state.src.charCodeAt(pos) === 32 && state.src.charCodeAt(pos + 1) === marker.charCodeAt(0) && state.src.charCodeAt(pos + 2) === marker.charCodeAt(0)) {
            foundClose = true;
            break;
          }
          pos++;
        }
        if (!foundClose) {
          return false;
        }
        if (!silent) {
          const token_o = state.push(`${tag}_open`, tag, 1);
          token_o.markup = doubleChar;
          const token_t = state.push("text", "", 0);
          token_t.content = state.src.slice(start + 3, pos);
          const token_c = state.push(`${tag}_close`, tag, -1);
          token_c.markup = doubleChar;
        }
        state.pos = pos + 3;
        return true;
      });
    }
  }
  function createScriptRule(name, marker, tag) {
    md.inline.ruler.before("emphasis", name, function(state, silent) {
      const start = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {
        return false;
      }
      if (start + 1 < max && state.src.charCodeAt(start + 1) === 32) {
        return false;
      }
      let pos = start + 1;
      let foundClose = false;
      while (pos < max) {
        if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {
          if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 32) {
            pos++;
            continue;
          }
          foundClose = true;
          break;
        }
        pos++;
      }
      if (!foundClose || pos === start + 1) {
        return false;
      }
      if (!silent) {
        const token_o = state.push(`${tag}_open`, tag, 1);
        token_o.markup = marker;
        const token_t = state.push("text", "", 0);
        token_t.content = state.src.slice(start + 1, pos);
        const token_c = state.push(`${tag}_close`, tag, -1);
        token_c.markup = marker;
      }
      state.pos = pos + 1;
      return true;
    });
  }
  createInlineRule("bold", "*", "strong");
  createInlineRule("italic_slash", "/", "em", true, true);
  createInlineRule("underline", "_", "u");
  createInlineRule("highlight", "=", "mark");
  createInlineRule("strikethrough", "-", "s");
  createScriptRule("superscript", "^", "sup");
  createScriptRule("subscript", "~", "sub");
}
function markdownCheckboxes(md) {
  md.block.ruler.before("list", "checkbox_block", (state, startLine, endLine, silent) => {
    const pos = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    const lineText = state.src.slice(pos, max);
    const match = lineText.match(/^\[([ xX-])\]\s/);
    if (!match) return false;
    if (silent) return true;
    const indentStack = [state.sCount[startLine]];
    state.push("bullet_list_open", "ul", 1);
    let nextLine = startLine;
    while (nextLine < endLine) {
      const linePos = state.bMarks[nextLine] + state.tShift[nextLine];
      const lineMax = state.eMarks[nextLine];
      const currentLine = state.src.slice(linePos, lineMax);
      const currentIndent = state.sCount[nextLine];
      if (currentIndent < indentStack[0]) break;
      const itemMatch = currentLine.match(/^\[([ xX-])\]\s/);
      if (!itemMatch) break;
      const tokenLi = state.push("list_item_open", "li", 1);
      tokenLi.map = [nextLine, nextLine + 1];
      tokenLi.markup = itemMatch[0].trim();
      state.push("paragraph_open", "p", 1);
      const tokenInline = state.push("inline", "", 0);
      tokenInline.content = currentLine;
      tokenInline.map = [nextLine, nextLine + 1];
      tokenInline.children = [];
      state.push("paragraph_close", "p", -1);
      let nextIndent = -1;
      let isNextList = false;
      if (nextLine + 1 < endLine) {
        const nextPos = state.bMarks[nextLine + 1] + state.tShift[nextLine + 1];
        const nextMax = state.eMarks[nextLine + 1];
        const nextStr = state.src.slice(nextPos, nextMax);
        nextIndent = state.sCount[nextLine + 1];
        const nextMatch = nextStr.match(/^\[([ xX-])\]\s/);
        if (nextMatch) {
          isNextList = true;
        }
      }
      if (isNextList && nextIndent > currentIndent) {
        state.push("bullet_list_open", "ul", 1);
        indentStack.push(nextIndent);
      } else {
        state.push("list_item_close", "li", -1);
        if (isNextList && nextIndent < currentIndent) {
          while (indentStack.length > 1 && nextIndent < indentStack[indentStack.length - 1]) {
            state.push("bullet_list_close", "ul", -1);
            indentStack.pop();
            state.push("list_item_close", "li", -1);
          }
        }
      }
      nextLine++;
    }
    while (indentStack.length > 0) {
      state.push("bullet_list_close", "ul", -1);
      indentStack.pop();
      if (indentStack.length > 0) {
        state.push("list_item_close", "li", -1);
      }
    }
    state.line = nextLine;
    return true;
  });
  md.core.ruler.push("checkbox_list", (state) => {
    const tokens = state.tokens;
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].type !== "inline") continue;
      let parentToken = null;
      let foundParent = false;
      if (tokens[i - 1] && tokens[i - 1].type === "list_item_open") {
        parentToken = tokens[i - 1];
        foundParent = true;
      } else if (tokens[i - 2] && tokens[i - 2].type === "list_item_open" && tokens[i - 1].type === "paragraph_open") {
        parentToken = tokens[i - 2];
        foundParent = true;
      }
      if (foundParent) {
        const token = tokens[i];
        const text = token.content;
        const pattern = /^\s*\[([ xX-])\]\s+/;
        const match = text.match(pattern);
        if (match) {
          const checkboxChar = match[1].toLowerCase();
          const isChecked = checkboxChar === "x";
          const isIndeterminate = checkboxChar === "-";
          const line = parentToken.map ? parentToken.map[0] : 0;
          parentToken.attrJoin("class", "task-list-item");
          if (isChecked) parentToken.attrJoin("class", "checked");
          if (isIndeterminate) parentToken.attrJoin("class", "indeterminate");
          token.content = text.slice(match[0].length);
          if (token.children && token.children.length > 0 && token.children[0].type === "text") {
            const childText = token.children[0].content;
            const childMatch = childText.match(pattern);
            if (childMatch) {
              token.children[0].content = childText.slice(childMatch[0].length);
            }
          }
          const checkbox = new state.Token("html_inline", "", 0);
          let checkedAttr = isChecked ? "checked" : "";
          let indeterminateAttr = isIndeterminate ? 'data-indeterminate="true"' : "";
          checkbox.content = `<input type="checkbox" class="task-list-item-checkbox" ${checkedAttr} ${indeterminateAttr} data-source-line="${line}" /> `;
          if (!token.children) token.children = [];
          token.children.unshift(checkbox);
        }
      }
    }
  });
}
function markdownRadios(md) {
  md.core.ruler.push("radio_lists", (state) => {
    const tokens = state.tokens;
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].type !== "inline") continue;
      const content = tokens[i].content;
      const radioRegex = /^(\( \)|\([xX]\))\s*/;
      if (radioRegex.test(content)) {
        let parentTokenIdx = -1;
        if (i >= 2 && tokens[i - 1].type === "paragraph_open" && tokens[i - 2].type === "list_item_open") {
          parentTokenIdx = i - 2;
        }
        if (parentTokenIdx !== -1) {
          const match = content.match(radioRegex);
          const isChecked = match[1].toLowerCase().includes("x");
          tokens[i].content = content.slice(match[0].length);
          if (tokens[i].children && tokens[i].children.length > 0) {
            const firstChild = tokens[i].children[0];
            if (firstChild.type === "text") {
              if (firstChild.content.startsWith(match[0])) {
                firstChild.content = firstChild.content.slice(match[0].length);
              } else {
                firstChild.content = firstChild.content.replace(radioRegex, "");
              }
            }
          }
          const radioToken = new state.Token("html_inline", "", 0);
          radioToken.content = `<input type="radio" class="task-list-item-radio" ${isChecked ? "checked" : ""} data-source-line="${tokens[i].map ? tokens[i].map[0] : ""}">`;
          if (tokens[i].map) {
            radioToken.content = radioToken.content.replace('data-source-line=""', `data-source-line="${tokens[i].map[0]}"`);
          }
          if (!tokens[i].children) tokens[i].children = [];
          tokens[i].children.unshift(radioToken);
          tokens[parentTokenIdx].attrJoin("class", "task-list-item");
          tokens[parentTokenIdx].attrJoin("class", "task-list-item-radio-wrapper");
        }
      }
    }
  });
}
function markdownCallouts(md) {
  function callout(state, startLine, endLine, silent) {
    const start = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    const lineText = state.src.slice(start, max);
    const simpleRegex = /^(\(!\)|\(\?\)|\(i\)|\(#\))(?:[ \t]+(.*))?$/;
    const customRegex = /^\(\s*:\s*([a-zA-Z0-9#]+)\s*:\s*\)(?:[ \t]+(.*))?$/;
    let type = "";
    let title = "";
    let color = "";
    let match = lineText.match(simpleRegex);
    if (match) {
      const marker = match[1];
      if (marker === "(!)") {
        type = "warning";
        title = "Warning";
        color = "#ff5f56";
      } else if (marker === "(?)") {
        type = "question";
        title = "Question";
        color = "#febc2e";
      } else if (marker === "(i)") {
        type = "info";
        title = "Info";
        color = "#28c7fa";
      } else if (marker === "(#)") {
        type = "default";
        title = "Note";
        color = "#888888";
      }
      if (match[2]) title = match[2];
    } else {
      match = lineText.match(customRegex);
      if (match) {
        type = "custom";
        color = match[1];
        title = match[2] || "Note";
      }
    }
    if (!type) return false;
    if (silent) return true;
    const nextLine = startLine + 1;
    let lastLine = startLine;
    const threshold = state.sCount[startLine];
    for (let next = nextLine; next < endLine; next++) {
      if (state.isEmpty(next)) continue;
      if (state.sCount[next] > threshold) {
        lastLine = next;
      } else {
        break;
      }
    }
    const tokenOpen = state.push("callout_open", "div", 1);
    tokenOpen.attrs = [["class", `callout callout-${type}`]];
    tokenOpen.map = [startLine, lastLine + 1];
    tokenOpen.attrs.push(["style", `--callout-color: ${color};`]);
    const tokenHeader = state.push("callout_header_open", "div", 1);
    tokenHeader.attrs = [["class", "callout-header"]];
    const tokenTitle = state.push("inline", "", 0);
    tokenTitle.content = title;
    tokenTitle.children = [];
    state.push("callout_header_close", "div", -1);
    if (lastLine > startLine) {
      const oldParentType = state.parentType;
      const oldBlkIndent = state.blkIndent;
      const oldSCounts = [];
      let minIndent = Infinity;
      for (let i = startLine + 1; i <= lastLine; i++) {
        if (!state.isEmpty(i)) {
          if (state.sCount[i] < minIndent) minIndent = state.sCount[i];
        }
      }
      for (let i = startLine + 1; i <= lastLine; i++) {
        oldSCounts[i] = state.sCount[i];
        if (state.sCount[i] >= minIndent) {
          state.sCount[i] -= minIndent;
        } else {
          state.sCount[i] = 0;
        }
      }
      state.parentType = "callout";
      state.blkIndent = 0;
      state.md.block.tokenize(state, startLine + 1, lastLine + 1);
      state.parentType = oldParentType;
      state.blkIndent = oldBlkIndent;
      for (let i = startLine + 1; i <= lastLine; i++) {
        state.sCount[i] = oldSCounts[i];
      }
    }
    state.push("callout_close", "div", -1);
    state.line = lastLine + 1;
    return true;
  }
  md.block.ruler.before("fence", "callout", callout, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
}
function markdownToggles(md) {
  md.core.ruler.push("list_toggles", (state) => {
    const tokens = state.tokens;
    const collapsedLines = state.env.collapsedLines || /* @__PURE__ */ new Set();
    const stack = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.type === "list_item_open") {
        stack.push({ index: i, hasChild: false });
      } else if (token.type === "list_item_close") {
        if (stack.length > 0) {
          const item = stack.pop();
          if (item.hasChild) {
            const openToken = tokens[item.index];
            openToken.attrJoin("class", "has-children");
            if (openToken.map && collapsedLines.has(openToken.map[0])) {
              openToken.attrJoin("class", "collapsed");
            }
            const toggleToken = new state.Token("html_inline", "", 0);
            const line = openToken.map ? openToken.map[0] : -1;
            toggleToken.content = `<span class="list-toggle" data-line="${line}"></span>`;
            let j = item.index + 1;
            while (j < i && tokens[j].type !== "inline") {
              j++;
            }
            if (j < i) {
              const inlineToken = tokens[j];
              if (!inlineToken.children) inlineToken.children = [];
              const toggleNode = new state.Token("html_inline", "", 0);
              toggleNode.content = `<span class="list-toggle" data-line="${line}"></span>`;
              inlineToken.children.unshift(toggleNode);
            }
          }
        }
      } else if (token.type === "bullet_list_open" || token.type === "ordered_list_open") {
        if (stack.length > 0) {
          stack[stack.length - 1].hasChild = true;
        }
      }
    }
  });
}
function markdownWikilinks(md, options = {}) {
  function parseWikilink(text) {
    const result = {
      target: "",
      heading: null,
      blockId: null,
      display: null
    };
    const pipeIndex = text.indexOf("|");
    let targetPart = text;
    if (pipeIndex !== -1) {
      targetPart = text.substring(0, pipeIndex);
      result.display = text.substring(pipeIndex + 1).trim();
    }
    const hashIndex = targetPart.indexOf("#");
    if (hashIndex !== -1) {
      result.target = targetPart.substring(0, hashIndex).trim();
      result.heading = targetPart.substring(hashIndex + 1).trim();
      return result;
    }
    const caretIndex = targetPart.indexOf("^");
    if (caretIndex !== -1) {
      result.target = targetPart.substring(0, caretIndex).trim();
      result.blockId = targetPart.substring(caretIndex + 1).trim();
      return result;
    }
    result.target = targetPart.trim();
    return result;
  }
  md.inline.ruler.before("emphasis", "wikilink", function(state, silent) {
    const start = state.pos;
    const max = state.posMax;
    if (start + 2 >= max || state.src.charCodeAt(start) !== 91 || // [
    state.src.charCodeAt(start + 1) !== 91) {
      return false;
    }
    let pos = start + 2;
    let foundClose = false;
    while (pos + 1 < max) {
      if (state.src.charCodeAt(pos) === 93 && // ]
      state.src.charCodeAt(pos + 1) === 93) {
        foundClose = true;
        break;
      }
      pos++;
    }
    if (!foundClose) {
      return false;
    }
    const content = state.src.slice(start + 2, pos);
    if (content.trim().length === 0) {
      return false;
    }
    if (!silent) {
      const parsed = parseWikilink(content);
      const token_o = state.push("link_open", "a", 1);
      token_o.attrSet("class", "wikilink");
      token_o.attrSet("href", "#");
      if (parsed.target) {
        token_o.attrSet("data-target", parsed.target);
      }
      if (parsed.heading) {
        token_o.attrSet("data-heading", parsed.heading);
      }
      if (parsed.blockId) {
        token_o.attrSet("data-block", parsed.blockId);
      }
      const token_t = state.push("text", "", 0);
      token_t.content = parsed.display || content;
      state.push("link_close", "a", -1);
    }
    state.pos = pos + 2;
    return true;
  });
}
function markdownBlockIds(md) {
  md.core.ruler.push("block_ids", (state) => {
    const tokens = state.tokens;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.type !== "inline" || !token.content) {
        continue;
      }
      const blockIdPattern = /\s\^([\w-]+)\s*$/;
      const match = token.content.match(blockIdPattern);
      if (match) {
        const blockId = match[1];
        token.content = token.content.replace(blockIdPattern, "");
        if (token.children && token.children.length > 0) {
          const lastChild = token.children[token.children.length - 1];
          if (lastChild.type === "text") {
            lastChild.content = lastChild.content.replace(blockIdPattern, "");
          }
        }
        let parentToken = null;
        for (let j = i - 1; j >= 0; j--) {
          const prev = tokens[j];
          if (prev.type.endsWith("_open") && prev.nesting === 1) {
            parentToken = prev;
            break;
          }
        }
        if (parentToken) {
          parentToken.attrSet("id", blockId);
        }
      }
    }
  });
}
function extractWikilinks(markdown) {
  const wikilinks = [];
  const pattern = /\[\[([^\]]+)\]\]/g;
  let match;
  while ((match = pattern.exec(markdown)) !== null) {
    const content = match[1];
    const wikilink = {
      raw: match[0],
      target: "",
      heading: null,
      blockId: null,
      display: null
    };
    const pipeIndex = content.indexOf("|");
    let targetPart = content;
    if (pipeIndex !== -1) {
      targetPart = content.substring(0, pipeIndex);
      wikilink.display = content.substring(pipeIndex + 1).trim();
    }
    const hashIndex = targetPart.indexOf("#");
    if (hashIndex !== -1) {
      wikilink.target = targetPart.substring(0, hashIndex).trim();
      wikilink.heading = targetPart.substring(hashIndex + 1).trim();
      wikilinks.push(wikilink);
      continue;
    }
    const caretIndex = targetPart.indexOf("^");
    if (caretIndex !== -1) {
      wikilink.target = targetPart.substring(0, caretIndex).trim();
      wikilink.blockId = targetPart.substring(caretIndex + 1).trim();
      wikilinks.push(wikilink);
      continue;
    }
    wikilink.target = targetPart.trim();
    wikilinks.push(wikilink);
  }
  return wikilinks;
}
function extractBlockIds(markdown) {
  const blockIds = [];
  const pattern = /\s\^([\w-]+)\s*$/gm;
  let match;
  while ((match = pattern.exec(markdown)) !== null) {
    blockIds.push(match[1]);
  }
  return blockIds;
}
function generateBlockId() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 5);
  return `block-${timestamp}-${random}`;
}
var wikilinkUtils = Object.freeze({
  __proto__: null,
  extractBlockIds,
  extractWikilinks,
  generateBlockId
});
function applyAllPlugins(md) {
  md.use(customSyntaxPlugin);
  md.use(markdownCheckboxes);
  md.use(markdownRadios);
  md.use(markdownCallouts);
  md.use(markdownToggles);
  md.use(markdownWikilinks);
  md.use(markdownBlockIds);
  return md;
}
var index = {
  customSyntaxPlugin,
  markdownCheckboxes,
  markdownRadios,
  markdownCallouts,
  markdownToggles,
  markdownWikilinks,
  markdownBlockIds,
  wikilinkUtils,
  applyAllPlugins
};
export {
  applyAllPlugins,
  customSyntaxPlugin,
  index as default,
  markdownBlockIds,
  markdownCallouts,
  markdownCheckboxes,
  markdownRadios,
  markdownToggles,
  markdownWikilinks,
  wikilinkUtils
};
//# sourceMappingURL=better-markdown.js.map
