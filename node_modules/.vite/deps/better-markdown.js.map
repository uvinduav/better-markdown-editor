{
  "version": 3,
  "sources": ["../../better-markdown/src/plugins/customSyntax.js", "../../better-markdown/src/plugins/checkboxes.js", "../../better-markdown/src/plugins/radios.js", "../../better-markdown/src/plugins/callouts.js", "../../better-markdown/src/plugins/toggles.js", "../../better-markdown/src/plugins/wikilinks.js", "../../better-markdown/src/plugins/blockIds.js", "../../better-markdown/src/utils/wikilinks.js", "../../better-markdown/src/index.js"],
  "sourcesContent": ["// Custom Markdown Syntax Plugin for markdown-it\r\n// Implements custom inline rules for text decorations\r\n\r\nfunction customSyntaxPlugin(md) {\r\n    // Helper function to detect if we're inside a URL\r\n    function isInsideUrl(text, pos) {\r\n        // Look backwards for URL patterns\r\n        const lookBehind = text.substring(Math.max(0, pos - 100), pos);\r\n\r\n        // Check for common URL protocols\r\n        const urlPatterns = [\r\n            /https?:\\/\\/[^\\s]*$/,\r\n            /ftp:\\/\\/[^\\s]*$/,\r\n            /www\\.[^\\s]*$/,\r\n        ];\r\n\r\n        for (const pattern of urlPatterns) {\r\n            if (pattern.test(lookBehind)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Check if we're inside markdown link syntax [text](url)\r\n        // Look for an opening parenthesis before current position and closing after\r\n        let parenDepth = 0;\r\n        for (let i = pos - 1; i >= 0; i--) {\r\n            if (lookBehind[lookBehind.length - (pos - i)] === ')') {\r\n                parenDepth++;\r\n            } else if (lookBehind[lookBehind.length - (pos - i)] === '(') {\r\n                if (parenDepth === 0) {\r\n                    // We found an opening paren, check if it's part of a link [...](...\r\n                    if (i > 0 && text[i - 1] === ']') {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                }\r\n                parenDepth--;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Helper function to create inline rules for standard decorations\r\n    function createInlineRule(name, marker, tag, allowDouble = true, skipInUrls = false) {\r\n        const singleChar = marker;\r\n        const doubleChar = marker + marker;\r\n\r\n        // Single character rule (no spaces): /word/\r\n        md.inline.ruler.before('emphasis', `${name}_single`, function (state, silent) {\r\n            const start = state.pos;\r\n            const max = state.posMax;\r\n\r\n            // Check if we're at the marker\r\n            if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {\r\n                return false;\r\n            }\r\n\r\n            // Skip if inside URL (for markers like /)\r\n            if (skipInUrls && isInsideUrl(state.src, start)) {\r\n                return false;\r\n            }\r\n\r\n            // Don't match if preceded by alphanumeric (to avoid conflicts in middle of words)\r\n            if (start > 0) {\r\n                const prevChar = state.src.charCodeAt(start - 1);\r\n                if ((prevChar >= 0x30 && prevChar <= 0x39) || // 0-9\r\n                    (prevChar >= 0x41 && prevChar <= 0x5A) || // A-Z\r\n                    (prevChar >= 0x61 && prevChar <= 0x7A)) { // a-z\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Check if next character is a space - if so, don't match single character version\r\n            if (start + 1 < max && state.src.charCodeAt(start + 1) === 0x20) {\r\n                return false;\r\n            }\r\n\r\n            // Find closing marker\r\n            let pos = start + 1;\r\n            let foundClose = false;\r\n\r\n            while (pos < max) {\r\n                if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {\r\n                    // Found potential closing marker\r\n                    // Make sure it's not followed by the same marker (double)\r\n                    if (pos + 1 < max && state.src.charCodeAt(pos + 1) === marker.charCodeAt(0)) {\r\n                        pos += 2;\r\n                        continue;\r\n                    }\r\n                    // Make sure closing marker is not preceded by space\r\n                    if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 0x20) {\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    foundClose = true;\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n\r\n            if (!foundClose || pos === start + 1) {\r\n                return false;\r\n            }\r\n\r\n            if (!silent) {\r\n                const token_o = state.push(`${tag}_open`, tag, 1);\r\n                token_o.markup = singleChar;\r\n\r\n                const token_t = state.push('text', '', 0);\r\n                token_t.content = state.src.slice(start + 1, pos);\r\n\r\n                const token_c = state.push(`${tag}_close`, tag, -1);\r\n                token_c.markup = singleChar;\r\n            }\r\n\r\n            state.pos = pos + 1;\r\n            return true;\r\n        });\r\n\r\n        // Double character rule (with spaces): // word //\r\n        if (allowDouble) {\r\n            md.inline.ruler.before('emphasis', `${name}_double`, function (state, silent) {\r\n                const start = state.pos;\r\n                const max = state.posMax;\r\n\r\n                // Check if we're at double marker\r\n                if (start + 1 >= max ||\r\n                    state.src.charCodeAt(start) !== marker.charCodeAt(0) ||\r\n                    state.src.charCodeAt(start + 1) !== marker.charCodeAt(0)) {\r\n                    return false;\r\n                }\r\n\r\n                // Must have space after opening marker\r\n                if (start + 2 >= max || state.src.charCodeAt(start + 2) !== 0x20) {\r\n                    return false;\r\n                }\r\n\r\n                // Find closing marker (space + double marker)\r\n                let pos = start + 3;\r\n                let foundClose = false;\r\n\r\n                while (pos + 2 < max) {\r\n                    if (state.src.charCodeAt(pos) === 0x20 &&\r\n                        state.src.charCodeAt(pos + 1) === marker.charCodeAt(0) &&\r\n                        state.src.charCodeAt(pos + 2) === marker.charCodeAt(0)) {\r\n                        foundClose = true;\r\n                        break;\r\n                    }\r\n                    pos++;\r\n                }\r\n\r\n                if (!foundClose) {\r\n                    return false;\r\n                }\r\n\r\n                if (!silent) {\r\n                    const token_o = state.push(`${tag}_open`, tag, 1);\r\n                    token_o.markup = doubleChar;\r\n\r\n                    const token_t = state.push('text', '', 0);\r\n                    token_t.content = state.src.slice(start + 3, pos);\r\n\r\n                    const token_c = state.push(`${tag}_close`, tag, -1);\r\n                    token_c.markup = doubleChar;\r\n                }\r\n\r\n                state.pos = pos + 3;\r\n                return true;\r\n            });\r\n        }\r\n    }\r\n\r\n    // Special function for superscript/subscript that allows mid-word usage\r\n    function createScriptRule(name, marker, tag) {\r\n        md.inline.ruler.before('emphasis', name, function (state, silent) {\r\n            const start = state.pos;\r\n            const max = state.posMax;\r\n\r\n            // Check if we're at the marker\r\n            if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {\r\n                return false;\r\n            }\r\n\r\n            // Check if next character is a space - if so, don't match\r\n            if (start + 1 < max && state.src.charCodeAt(start + 1) === 0x20) {\r\n                return false;\r\n            }\r\n\r\n            // Find closing marker\r\n            let pos = start + 1;\r\n            let foundClose = false;\r\n\r\n            while (pos < max) {\r\n                if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {\r\n                    // Found closing marker\r\n                    // Make sure closing marker is not preceded by space\r\n                    if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 0x20) {\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    foundClose = true;\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n\r\n            if (!foundClose || pos === start + 1) {\r\n                return false;\r\n            }\r\n\r\n            if (!silent) {\r\n                const token_o = state.push(`${tag}_open`, tag, 1);\r\n                token_o.markup = marker;\r\n\r\n                const token_t = state.push('text', '', 0);\r\n                token_t.content = state.src.slice(start + 1, pos);\r\n\r\n                const token_c = state.push(`${tag}_close`, tag, -1);\r\n                token_c.markup = marker;\r\n            }\r\n\r\n            state.pos = pos + 1;\r\n            return true;\r\n        });\r\n    }\r\n\r\n    // Register all custom syntax rules\r\n    // Bold and Italic (core formatting)\r\n    createInlineRule('bold', '*', 'strong');\r\n    createInlineRule('italic_slash', '/', 'em', true, true); // skipInUrls = true\r\n\r\n    // Other decorations\r\n    createInlineRule('underline', '_', 'u');\r\n    createInlineRule('highlight', '=', 'mark');\r\n    createInlineRule('strikethrough', '-', 's');\r\n    createScriptRule('superscript', '^', 'sup');\r\n    createScriptRule('subscript', '~', 'sub');\r\n}\r\n\r\nexport default customSyntaxPlugin;\r\n", "\r\nexport default function markdownCheckboxes(md) {\r\n    // 1. Block Rule: Enable \"[ ] Text\" as a top-level list item\r\n    md.block.ruler.before('list', 'checkbox_block', (state, startLine, endLine, silent) => {\r\n        const pos = state.bMarks[startLine] + state.tShift[startLine];\r\n        const max = state.eMarks[startLine];\r\n        const lineText = state.src.slice(pos, max);\r\n\r\n        // Regex: [x](space)\r\n        const match = lineText.match(/^\\[([ xX-])\\]\\s/);\r\n\r\n        if (!match) return false;\r\n\r\n        if (silent) return true;\r\n\r\n        // Stack to track indentation matches.\r\n        // We start with the root list.\r\n        const indentStack = [state.sCount[startLine]];\r\n\r\n        state.push('bullet_list_open', 'ul', 1);\r\n\r\n        let nextLine = startLine;\r\n\r\n        while (nextLine < endLine) {\r\n            const linePos = state.bMarks[nextLine] + state.tShift[nextLine];\r\n            const lineMax = state.eMarks[nextLine];\r\n            const currentLine = state.src.slice(linePos, lineMax);\r\n            const currentIndent = state.sCount[nextLine];\r\n\r\n            // Note: If indentation is corrupt (less than root), loop should have handled it in lookahead or breaks here\r\n            if (currentIndent < indentStack[0]) break;\r\n\r\n            const itemMatch = currentLine.match(/^\\[([ xX-])\\]\\s/);\r\n            if (!itemMatch) break;\r\n\r\n            // 1. Open Item\r\n            const tokenLi = state.push('list_item_open', 'li', 1);\r\n            tokenLi.map = [nextLine, nextLine + 1];\r\n            tokenLi.markup = itemMatch[0].trim();\r\n\r\n            // 2. Content\r\n            state.push('paragraph_open', 'p', 1);\r\n            const tokenInline = state.push('inline', '', 0);\r\n            tokenInline.content = currentLine;\r\n            tokenInline.map = [nextLine, nextLine + 1];\r\n            tokenInline.children = [];\r\n            state.push('paragraph_close', 'p', -1);\r\n\r\n            // 3. Lookahead logic\r\n            let nextIndent = -1;\r\n            let isNextList = false;\r\n\r\n            if (nextLine + 1 < endLine) {\r\n                // Check next line content\r\n                // We use sCount but we must verify it is actually a list item line\r\n                // Otherwise it might be lazy text?\r\n                const nextPos = state.bMarks[nextLine + 1] + state.tShift[nextLine + 1];\r\n                const nextMax = state.eMarks[nextLine + 1];\r\n                const nextStr = state.src.slice(nextPos, nextMax);\r\n\r\n                // If line is empty, skip? No, strict list.\r\n                // Note: sCount gives indent.\r\n                nextIndent = state.sCount[nextLine + 1];\r\n                const nextMatch = nextStr.match(/^\\[([ xX-])\\]\\s/);\r\n                if (nextMatch) {\r\n                    isNextList = true;\r\n                }\r\n            }\r\n\r\n            if (isNextList && nextIndent > currentIndent) {\r\n                // Next is Child -> Open Nested List\r\n                state.push('bullet_list_open', 'ul', 1);\r\n                indentStack.push(nextIndent);\r\n                // DO NOT CLOSE LI\r\n            } else {\r\n                // Next is Sibling or Ancestor or non-list -> Close LI\r\n                state.push('list_item_close', 'li', -1);\r\n\r\n                if (isNextList && nextIndent < currentIndent) {\r\n                    // Pop stack until we find match\r\n                    // This handles closing nested lists AND their parent LIs\r\n                    while (indentStack.length > 1 && nextIndent < indentStack[indentStack.length - 1]) {\r\n                        state.push('bullet_list_close', 'ul', -1);\r\n                        indentStack.pop();\r\n                        // Logic: If we closed a nested list, we are now back in the scope of the Parent LI.\r\n                        // But that Parent LI is effectively \"done\" with its content + children.\r\n                        // So we must close it too.\r\n                        state.push('list_item_close', 'li', -1);\r\n                    }\r\n\r\n                    // Edge case: nextIndent mismatches stack?\r\n                    // We treat it as matching the nearest valid parent (standard markdown flex)\r\n                }\r\n                else if (!isNextList) {\r\n                    // End of block. Close everything back to root.\r\n                    // Loop handles nextLine check\r\n                }\r\n            }\r\n\r\n            nextLine++;\r\n        }\r\n\r\n        // Final Cleanup: Close remaining open lists\r\n        while (indentStack.length > 0) {\r\n            state.push('bullet_list_close', 'ul', -1);\r\n            indentStack.pop();\r\n            // If we popped a nested list, close its parent LI\r\n            // Exception: The very last UL (Root) does NOT have a parent LI to close here \r\n            // because strict loop structure separates them.\r\n            // Wait.\r\n            // If stack [Root, Child].\r\n            // We close Child UL. Then Child LI must be closed?\r\n            // See lookahead logic: We closed Child LI inside the loop! \r\n            // \"Else -> Close LI\".\r\n            // So last item LI is always closed.\r\n            // So we only close PARENT LIs if we have nested open.\r\n\r\n            // Correction:\r\n            // In lookahead, if nextIndent > current, we LEFT LI OPEN.\r\n            // So for every item remaining in stack (except root), there is an OPEN LI waiting.\r\n            if (indentStack.length > 0) {\r\n                state.push('list_item_close', 'li', -1);\r\n            }\r\n        }\r\n\r\n        state.line = nextLine;\r\n        return true;\r\n    });\r\n\r\n    // 2. Core Rule: Convert \"[ ] Text\" in list items to <input>\r\n    md.core.ruler.push('checkbox_list', (state) => {\r\n        const tokens = state.tokens;\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            if (tokens[i].type !== 'inline') continue;\r\n\r\n            let parentToken = null;\r\n            let foundParent = false;\r\n\r\n            if (tokens[i - 1] && tokens[i - 1].type === 'list_item_open') {\r\n                parentToken = tokens[i - 1];\r\n                foundParent = true;\r\n            }\r\n            else if (tokens[i - 2] && tokens[i - 2].type === 'list_item_open' && tokens[i - 1].type === 'paragraph_open') {\r\n                parentToken = tokens[i - 2];\r\n                foundParent = true;\r\n            }\r\n\r\n            if (foundParent) {\r\n                const token = tokens[i];\r\n                const text = token.content;\r\n                const pattern = /^\\s*\\[([ xX-])\\]\\s+/;\r\n                const match = text.match(pattern);\r\n\r\n                if (match) {\r\n                    const checkboxChar = match[1].toLowerCase();\r\n                    const isChecked = checkboxChar === 'x';\r\n                    const isIndeterminate = checkboxChar === '-';\r\n\r\n                    const line = parentToken.map ? parentToken.map[0] : 0;\r\n\r\n                    parentToken.attrJoin('class', 'task-list-item');\r\n                    if (isChecked) parentToken.attrJoin('class', 'checked');\r\n                    if (isIndeterminate) parentToken.attrJoin('class', 'indeterminate');\r\n\r\n                    token.content = text.slice(match[0].length);\r\n\r\n                    if (token.children && token.children.length > 0 && token.children[0].type === 'text') {\r\n                        const childText = token.children[0].content;\r\n                        const childMatch = childText.match(pattern);\r\n                        if (childMatch) {\r\n                            token.children[0].content = childText.slice(childMatch[0].length);\r\n                        }\r\n                    }\r\n\r\n                    const checkbox = new state.Token('html_inline', '', 0);\r\n                    let checkedAttr = isChecked ? 'checked' : '';\r\n                    let indeterminateAttr = isIndeterminate ? 'data-indeterminate=\"true\"' : '';\r\n\r\n                    checkbox.content = `<input type=\"checkbox\" class=\"task-list-item-checkbox\" ${checkedAttr} ${indeterminateAttr} data-source-line=\"${line}\" /> `;\r\n\r\n                    if (!token.children) token.children = [];\r\n                    token.children.unshift(checkbox);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\r\n// markdownRadios.js\r\n// Markdownlint plugin to parse radio button lists ( ) and (x)\r\n\r\nexport default function markdownRadios(md) {\r\n    md.core.ruler.push('radio_lists', (state) => {\r\n        const tokens = state.tokens;\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            if (tokens[i].type !== 'inline') continue;\r\n\r\n            const content = tokens[i].content;\r\n            // Allow ( ) or (x) with optional space after\r\n            const radioRegex = /^(\\( \\)|\\([xX]\\))\\s*/;\r\n\r\n            if (radioRegex.test(content)) {\r\n                // Find parent list item\r\n                // Scan backwards from i to find the closest list_item_open that hasn't been closed\r\n                // Actually, in the flat token stream, the immediate parent of the 'inline' token's paragraph is usually the list item.\r\n                // Structure: list_item_open, paragraph_open, inline, paragraph_close, list_item_close\r\n\r\n                let parentTokenIdx = -1;\r\n                // Look back specifically for the structure [list_item_open, paragraph_open, inline]\r\n                if (i >= 2 && tokens[i - 1].type === 'paragraph_open' && tokens[i - 2].type === 'list_item_open') {\r\n                    parentTokenIdx = i - 2;\r\n                }\r\n\r\n                if (parentTokenIdx !== -1) {\r\n                    const match = content.match(radioRegex);\r\n                    const isChecked = match[1].toLowerCase().includes('x');\r\n\r\n                    // Consume the marker from content\r\n                    tokens[i].content = content.slice(match[0].length);\r\n\r\n                    // Also strip from the first text child if present\r\n                    if (tokens[i].children && tokens[i].children.length > 0) {\r\n                        const firstChild = tokens[i].children[0];\r\n                        if (firstChild.type === 'text') {\r\n                            // Only slice if it starts with the match\r\n                            // (The inline token content is a concatenation of children)\r\n                            // Sometimes children are splitting syntax. \r\n                            // But usually the text node starts with the marker.\r\n                            // Let's safe check.\r\n                            if (firstChild.content.startsWith(match[0])) {\r\n                                firstChild.content = firstChild.content.slice(match[0].length);\r\n                            } else {\r\n                                // Fallback: regex search/replace on first text node?\r\n                                // Or just rely on token.content update? \r\n                                // Markdown-it renderer uses children if present.\r\n                                // It's safer to just set content.\r\n                                // Let's assume standard text node first.\r\n                                firstChild.content = firstChild.content.replace(radioRegex, '');\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Create Radio Input Token\r\n                    const radioToken = new state.Token('html_inline', '', 0);\r\n                    // Use interactive attributes\r\n                    // Note: We don't use 'disabled' because we want clicks to bubble to React\r\n                    radioToken.content = `<input type=\"radio\" class=\"task-list-item-radio\" ${isChecked ? 'checked' : ''} data-source-line=\"${tokens[i].map ? tokens[i].map[0] : ''}\">`;\r\n\r\n                    // Ensure source line map\r\n                    if (tokens[i].map) {\r\n                        radioToken.content = radioToken.content.replace('data-source-line=\"\"', `data-source-line=\"${tokens[i].map[0]}\"`);\r\n                    }\r\n\r\n                    // Prepend input to children\r\n                    if (!tokens[i].children) tokens[i].children = [];\r\n                    tokens[i].children.unshift(radioToken);\r\n\r\n                    // Add class to List Item (<li>)\r\n                    tokens[parentTokenIdx].attrJoin('class', 'task-list-item');\r\n                    // Add specific class for radios to help styling if needed\r\n                    tokens[parentTokenIdx].attrJoin('class', 'task-list-item-radio-wrapper');\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\r\n// src/markdownCallouts.js\r\n// Plugin to support custom Callout blocks with indentation-based content.\r\n\r\nexport default function markdownCallouts(md) {\r\n\r\n    function callout(state, startLine, endLine, silent) {\r\n        // Line processing\r\n        const start = state.bMarks[startLine] + state.tShift[startLine];\r\n        const max = state.eMarks[startLine];\r\n        const lineText = state.src.slice(start, max);\r\n\r\n        // Regex for Callout Headers: (!) Title, (#) Title, (:color:) Title\r\n        const simpleRegex = /^(\\(!\\)|\\(\\?\\)|\\(i\\)|\\(#\\))(?:[ \\t]+(.*))?$/;\r\n        // Robust Custom Regex: Allow spaces inside parens e.g. ( :red: )\r\n        const customRegex = /^\\(\\s*:\\s*([a-zA-Z0-9#]+)\\s*:\\s*\\)(?:[ \\t]+(.*))?$/;\r\n\r\n        let type = '';\r\n        let title = '';\r\n        let color = '';\r\n\r\n        let match = lineText.match(simpleRegex);\r\n        if (match) {\r\n            const marker = match[1];\r\n            if (marker === '(!)') { type = 'warning'; title = 'Warning'; color = '#ff5f56'; }\r\n            else if (marker === '(?)') { type = 'question'; title = 'Question'; color = '#febc2e'; }\r\n            else if (marker === '(i)') { type = 'info'; title = 'Info'; color = '#28c7fa'; }\r\n            else if (marker === '(#)') { type = 'default'; title = 'Note'; color = '#888888'; }\r\n\r\n            if (match[2]) title = match[2];\r\n        } else {\r\n            match = lineText.match(customRegex);\r\n            if (match) {\r\n                type = 'custom';\r\n                color = match[1];\r\n                title = match[2] || 'Note';\r\n            }\r\n        }\r\n\r\n        if (!type) return false;\r\n        if (silent) return true;\r\n\r\n        // Determine Body Range\r\n        const nextLine = startLine + 1;\r\n        let lastLine = startLine;\r\n\r\n        // We look for lines indented MORE than the start line\r\n        // NOTE: state.sCount[startLine] includes the initial indent of the header line itself\r\n        // e.g. if header is at 0 indent, body must be > 0.\r\n        // If header is inside a list (indent 2), body must be > 2.\r\n\r\n        const threshold = state.sCount[startLine];\r\n\r\n        for (let next = nextLine; next < endLine; next++) {\r\n            if (state.isEmpty(next)) continue;\r\n\r\n            if (state.sCount[next] > threshold) {\r\n                lastLine = next;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Generate Container Token\r\n        const tokenOpen = state.push('callout_open', 'div', 1);\r\n        tokenOpen.attrs = [['class', `callout callout-${type}`]];\r\n        tokenOpen.map = [startLine, lastLine + 1];\r\n        tokenOpen.attrs.push(['style', `--callout-color: ${color};`]);\r\n\r\n        // Generate Header\r\n        const tokenHeader = state.push('callout_header_open', 'div', 1);\r\n        tokenHeader.attrs = [['class', 'callout-header']];\r\n\r\n        const tokenTitle = state.push('inline', '', 0);\r\n        tokenTitle.content = title;\r\n        tokenTitle.children = [];\r\n\r\n        state.push('callout_header_close', 'div', -1);\r\n\r\n        // Body Parsing with Indentation Strip\r\n        // Problem: If user indents by 4 spaces, default tokenizer sees \"Code Block\".\r\n        // Solution: We must \"shift\" the parser view so it sees 0 indentation for the body lines.\r\n        // We temporarily modify state.sCount and state.blkIndent.\r\n\r\n        if (lastLine > startLine) {\r\n            const oldParentType = state.parentType;\r\n            const oldBlkIndent = state.blkIndent;\r\n\r\n            // Calculate how much to strip. \r\n            // Often we strip 'threshold + 1' or just 'threshold' if we want tight packing?\r\n            // Usually, standard indented blocks strip relative to parent.\r\n            // Let's sweep and shift sCount.\r\n            // But we must restore them!\r\n            const oldSCounts = [];\r\n\r\n            // We want the \"visual indent\" of the body to be effectively 0 relative to the block.\r\n            // Find the minimum indent of the body lines?\r\n            // Or just strip 'threshold + N'?\r\n            // Usually, user indents by Tab (4) or 2 spaces.\r\n            // Let's assume we strip ALL common indentation?\r\n            // Or just strip `threshold`. \r\n            // If header is at 0, and body at 4. We strip 0? No, we need to strip 4 to make it a paragraph.\r\n            // If we strip 4, sCount becomes 0. Paragraph.\r\n\r\n            // Find minimum indent of non-empty lines in body\r\n            let minIndent = Infinity;\r\n            for (let i = startLine + 1; i <= lastLine; i++) {\r\n                if (!state.isEmpty(i)) {\r\n                    if (state.sCount[i] < minIndent) minIndent = state.sCount[i];\r\n                }\r\n            }\r\n\r\n            // Strip `minIndent` from all lines\r\n            for (let i = startLine + 1; i <= lastLine; i++) {\r\n                oldSCounts[i] = state.sCount[i];\r\n                if (state.sCount[i] >= minIndent) {\r\n                    state.sCount[i] -= minIndent;\r\n                } else {\r\n                    state.sCount[i] = 0;\r\n                }\r\n            }\r\n\r\n            state.parentType = 'callout';\r\n            state.blkIndent = 0; // Reset block indent expectation for inner content?\r\n\r\n            state.md.block.tokenize(state, startLine + 1, lastLine + 1);\r\n\r\n            // Restore\r\n            state.parentType = oldParentType;\r\n            state.blkIndent = oldBlkIndent;\r\n            for (let i = startLine + 1; i <= lastLine; i++) {\r\n                state.sCount[i] = oldSCounts[i];\r\n            }\r\n        }\r\n\r\n        state.push('callout_close', 'div', -1);\r\n\r\n        state.line = lastLine + 1;\r\n        return true;\r\n    }\r\n\r\n    md.block.ruler.before('fence', 'callout', callout, {\r\n        alt: ['paragraph', 'reference', 'blockquote', 'list']\r\n    });\r\n}\r\n", "\r\nexport default function markdownToggles(md) {\r\n    // Core Rule: Identify list items with children and inject toggles\r\n    md.core.ruler.push('list_toggles', (state) => {\r\n        const tokens = state.tokens;\r\n        const collapsedLines = state.env.collapsedLines || new Set();\r\n\r\n        // simple stack: { tokenIndex: number, hasChild: boolean }\r\n        const stack = [];\r\n\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n\r\n            if (token.type === 'list_item_open') {\r\n                stack.push({ index: i, hasChild: false });\r\n            }\r\n            else if (token.type === 'list_item_close') {\r\n                if (stack.length > 0) {\r\n                    const item = stack.pop();\r\n                    if (item.hasChild) {\r\n                        // Mark the opening token\r\n                        const openToken = tokens[item.index];\r\n                        openToken.attrJoin('class', 'has-children');\r\n\r\n                        // Check if collapsed\r\n                        // Use map[0] (start line) as identifier\r\n                        if (openToken.map && collapsedLines.has(openToken.map[0])) {\r\n                            openToken.attrJoin('class', 'collapsed');\r\n                        }\r\n\r\n                        // Inject Toggle Button\r\n                        // We need to inject it into the CONTENT of the list item.\r\n                        // The next tokens are usually `paragraph_open`, `inline`...\r\n                        // If we inject a separate token before paragraph, it renders inside LI but before P.\r\n                        // That works.\r\n\r\n                        const toggleToken = new state.Token('html_inline', '', 0);\r\n                        const line = openToken.map ? openToken.map[0] : -1;\r\n                        toggleToken.content = `<span class=\"list-toggle\" data-line=\"${line}\"></span>`;\r\n\r\n                        // Insert after openToken\r\n                        // We can't splice safely while iterating? \r\n                        // Actually we can, but logic gets complex with indices.\r\n                        // Better: Prepend to the children of the first inline token? \r\n                        // Or insert a simpler token?\r\n\r\n                        // Let's modify the stream?\r\n                        // \"tokens.splice\" is expensive O(N).\r\n                        // Alternative: Add it to the 'inline' token children.\r\n\r\n                        // Find the first inline token inside this LI\r\n                        let j = item.index + 1;\r\n                        while (j < i && tokens[j].type !== 'inline') {\r\n                            j++;\r\n                        }\r\n\r\n                        if (j < i) {\r\n                            // Found inline token (content of the LI)\r\n                            const inlineToken = tokens[j];\r\n                            if (!inlineToken.children) inlineToken.children = [];\r\n\r\n                            // Create inline token for the toggle\r\n                            const toggleNode = new state.Token('html_inline', '', 0);\r\n                            toggleNode.content = `<span class=\"list-toggle\" data-line=\"${line}\"></span>`;\r\n\r\n                            // Prepend\r\n                            inlineToken.children.unshift(toggleNode);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (token.type === 'bullet_list_open' || token.type === 'ordered_list_open') {\r\n                // If we are inside an LI, marks it as having a child\r\n                if (stack.length > 0) {\r\n                    stack[stack.length - 1].hasChild = true;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n", "// Wikilinks Plugin for markdown-it\r\n// Implements Obsidian-style [[wikilink]] syntax\r\n// Supports: [[Note]], [[Note#heading]], [[Note^block-id]], [[Note|Display Text]]\r\n\r\nexport default function markdownWikilinks(md, options = {}) {\r\n    // Parse wikilink syntax and extract components\r\n    function parseWikilink(text) {\r\n        // Pattern: [[target|display]] or [[target#heading]] or [[target^block]] or [[target]]\r\n        const result = {\r\n            target: '',\r\n            heading: null,\r\n            blockId: null,\r\n            display: null\r\n        };\r\n\r\n        // Check for display text separator |\r\n        const pipeIndex = text.indexOf('|');\r\n        let targetPart = text;\r\n\r\n        if (pipeIndex !== -1) {\r\n            targetPart = text.substring(0, pipeIndex);\r\n            result.display = text.substring(pipeIndex + 1).trim();\r\n        }\r\n\r\n        // Check for heading anchor #\r\n        const hashIndex = targetPart.indexOf('#');\r\n        if (hashIndex !== -1) {\r\n            result.target = targetPart.substring(0, hashIndex).trim();\r\n            result.heading = targetPart.substring(hashIndex + 1).trim();\r\n            return result;\r\n        }\r\n\r\n        // Check for block anchor ^\r\n        const caretIndex = targetPart.indexOf('^');\r\n        if (caretIndex !== -1) {\r\n            result.target = targetPart.substring(0, caretIndex).trim();\r\n            result.blockId = targetPart.substring(caretIndex + 1).trim();\r\n            return result;\r\n        }\r\n\r\n        // Just a simple target\r\n        result.target = targetPart.trim();\r\n        return result;\r\n    }\r\n\r\n    // Inline rule to detect [[...]] patterns\r\n    md.inline.ruler.before('emphasis', 'wikilink', function (state, silent) {\r\n        const start = state.pos;\r\n        const max = state.posMax;\r\n\r\n        // Check if we're at [[\r\n        if (start + 2 >= max ||\r\n            state.src.charCodeAt(start) !== 0x5B || // [\r\n            state.src.charCodeAt(start + 1) !== 0x5B) { // [\r\n            return false;\r\n        }\r\n\r\n        // Find closing ]]\r\n        let pos = start + 2;\r\n        let foundClose = false;\r\n\r\n        while (pos + 1 < max) {\r\n            if (state.src.charCodeAt(pos) === 0x5D && // ]\r\n                state.src.charCodeAt(pos + 1) === 0x5D) { // ]\r\n                foundClose = true;\r\n                break;\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        if (!foundClose) {\r\n            return false;\r\n        }\r\n\r\n        // Extract content between [[ and ]]\r\n        const content = state.src.slice(start + 2, pos);\r\n\r\n        // Don't match empty wikilinks\r\n        if (content.trim().length === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (!silent) {\r\n            const parsed = parseWikilink(content);\r\n\r\n            // Create link token\r\n            const token_o = state.push('link_open', 'a', 1);\r\n            token_o.attrSet('class', 'wikilink');\r\n            token_o.attrSet('href', '#'); // Placeholder, developers should override click behavior\r\n\r\n            // Add data attributes for developer use\r\n            if (parsed.target) {\r\n                token_o.attrSet('data-target', parsed.target);\r\n            }\r\n            if (parsed.heading) {\r\n                token_o.attrSet('data-heading', parsed.heading);\r\n            }\r\n            if (parsed.blockId) {\r\n                token_o.attrSet('data-block', parsed.blockId);\r\n            }\r\n\r\n            // Text content\r\n            const token_t = state.push('text', '', 0);\r\n            token_t.content = parsed.display || content;\r\n\r\n            // Close link\r\n            const token_c = state.push('link_close', 'a', -1);\r\n        }\r\n\r\n        state.pos = pos + 2; // Move past ]]\r\n        return true;\r\n    });\r\n}\r\n", "// Block IDs Plugin for markdown-it\r\n// Implements Obsidian-style block identifiers: ^block-id at end of lines\r\n// Adds id attributes to rendered HTML blocks for direct linking\r\n\r\nexport default function markdownBlockIds(md) {\r\n    // Core rule to process block IDs\r\n    md.core.ruler.push('block_ids', (state) => {\r\n        const tokens = state.tokens;\r\n\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n\r\n            // Only process inline tokens (text content)\r\n            if (token.type !== 'inline' || !token.content) {\r\n                continue;\r\n            }\r\n\r\n            // Check for block ID pattern at end of line: ^block-id\r\n            // Pattern: space + ^ + alphanumeric/dash/underscore id\r\n            const blockIdPattern = /\\s\\^([\\w-]+)\\s*$/;\r\n            const match = token.content.match(blockIdPattern);\r\n\r\n            if (match) {\r\n                const blockId = match[1];\r\n\r\n                // Remove the block ID from visible content\r\n                token.content = token.content.replace(blockIdPattern, '');\r\n\r\n                // Update children if they exist\r\n                if (token.children && token.children.length > 0) {\r\n                    const lastChild = token.children[token.children.length - 1];\r\n                    if (lastChild.type === 'text') {\r\n                        lastChild.content = lastChild.content.replace(blockIdPattern, '');\r\n                    }\r\n                }\r\n\r\n                // Find the parent block token (paragraph, list item, heading, etc.)\r\n                let parentToken = null;\r\n\r\n                // Look backwards for opening block token\r\n                for (let j = i - 1; j >= 0; j--) {\r\n                    const prev = tokens[j];\r\n                    if (prev.type.endsWith('_open') && prev.nesting === 1) {\r\n                        parentToken = prev;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Add id attribute to parent block\r\n                if (parentToken) {\r\n                    parentToken.attrSet('id', blockId);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n", "// Utility functions for wikilinks and block IDs\r\n// These are helper functions for developers integrating better-markdown\r\n\r\n/**\r\n * Extract all wikilinks from markdown text\r\n * @param {string} markdown - The markdown text to parse\r\n * @returns {Array} Array of wikilink objects with target, heading, blockId, display properties\r\n */\r\nexport function extractWikilinks(markdown) {\r\n    const wikilinks = [];\r\n    const pattern = /\\[\\[([^\\]]+)\\]\\]/g;\r\n    let match;\r\n\r\n    while ((match = pattern.exec(markdown)) !== null) {\r\n        const content = match[1];\r\n        const wikilink = {\r\n            raw: match[0],\r\n            target: '',\r\n            heading: null,\r\n            blockId: null,\r\n            display: null\r\n        };\r\n\r\n        // Check for display text separator |\r\n        const pipeIndex = content.indexOf('|');\r\n        let targetPart = content;\r\n\r\n        if (pipeIndex !== -1) {\r\n            targetPart = content.substring(0, pipeIndex);\r\n            wikilink.display = content.substring(pipeIndex + 1).trim();\r\n        }\r\n\r\n        // Check for heading anchor #\r\n        const hashIndex = targetPart.indexOf('#');\r\n        if (hashIndex !== -1) {\r\n            wikilink.target = targetPart.substring(0, hashIndex).trim();\r\n            wikilink.heading = targetPart.substring(hashIndex + 1).trim();\r\n            wikilinks.push(wikilink);\r\n            continue;\r\n        }\r\n\r\n        // Check for block anchor ^\r\n        const caretIndex = targetPart.indexOf('^');\r\n        if (caretIndex !== -1) {\r\n            wikilink.target = targetPart.substring(0, caretIndex).trim();\r\n            wikilink.blockId = targetPart.substring(caretIndex + 1).trim();\r\n            wikilinks.push(wikilink);\r\n            continue;\r\n        }\r\n\r\n        // Just a simple target\r\n        wikilink.target = targetPart.trim();\r\n        wikilinks.push(wikilink);\r\n    }\r\n\r\n    return wikilinks;\r\n}\r\n\r\n/**\r\n * Extract all block IDs from markdown text\r\n * @param {string} markdown - The markdown text to parse\r\n * @returns {Array} Array of block ID strings\r\n */\r\nexport function extractBlockIds(markdown) {\r\n    const blockIds = [];\r\n    const pattern = /\\s\\^([\\w-]+)\\s*$/gm;\r\n    let match;\r\n\r\n    while ((match = pattern.exec(markdown)) !== null) {\r\n        blockIds.push(match[1]);\r\n    }\r\n\r\n    return blockIds;\r\n}\r\n\r\n/**\r\n * Generate a unique block ID\r\n * This is a simple timestamp-based implementation\r\n * Developers can override this with their own strategy\r\n * @returns {string} A unique block ID\r\n */\r\nexport function generateBlockId() {\r\n    const timestamp = Date.now().toString(36); // Base36 for shorter strings\r\n    const random = Math.random().toString(36).substring(2, 5); // 3 random chars\r\n    return `block-${timestamp}-${random}`;\r\n}\r\n", "// Main entry point for better-markdown library\r\n// Export all markdown-it plugins for use in any editor (CodeMirror, Monaco, etc.)\r\n\r\n// Import all plugins\r\nimport customSyntaxPlugin from './plugins/customSyntax.js';\r\nimport markdownCheckboxes from './plugins/checkboxes.js';\r\nimport markdownRadios from './plugins/radios.js';\r\nimport markdownCallouts from './plugins/callouts.js';\r\nimport markdownToggles from './plugins/toggles.js';\r\nimport markdownWikilinks from './plugins/wikilinks.js';\r\nimport markdownBlockIds from './plugins/blockIds.js';\r\n\r\n// Import utilities\r\nimport * as wikilinkUtils from './utils/wikilinks.js';\r\n\r\n// Named exports for individual plugins\r\nexport {\r\n    customSyntaxPlugin,\r\n    markdownCheckboxes,\r\n    markdownRadios,\r\n    markdownCallouts,\r\n    markdownToggles,\r\n    markdownWikilinks,\r\n    markdownBlockIds,\r\n    wikilinkUtils\r\n};\r\n\r\n/**\r\n * Convenience function to apply all plugins to a markdown-it instance\r\n * @param {MarkdownIt} md - The markdown-it instance\r\n * @returns {MarkdownIt} The same instance with all plugins applied\r\n * \r\n * @example\r\n * import MarkdownIt from 'markdown-it';\r\n * import { applyAllPlugins } from 'better-markdown';\r\n * \r\n * const md = new MarkdownIt();\r\n * applyAllPlugins(md);\r\n */\r\nexport function applyAllPlugins(md) {\r\n    md.use(customSyntaxPlugin);\r\n    md.use(markdownCheckboxes);\r\n    md.use(markdownRadios);\r\n    md.use(markdownCallouts);\r\n    md.use(markdownToggles);\r\n    md.use(markdownWikilinks);\r\n    md.use(markdownBlockIds);\r\n    return md;\r\n}\r\n\r\n// Default export with all plugins and utilities\r\nexport default {\r\n    customSyntaxPlugin,\r\n    markdownCheckboxes,\r\n    markdownRadios,\r\n    markdownCallouts,\r\n    markdownToggles,\r\n    markdownWikilinks,\r\n    markdownBlockIds,\r\n    wikilinkUtils,\r\n    applyAllPlugins\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
