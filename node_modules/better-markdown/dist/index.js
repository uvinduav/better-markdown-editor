// Custom Markdown Syntax Plugin for markdown-it
// Implements custom inline rules for text decorations

function customSyntaxPlugin(md) {
    // Helper function to detect if we're inside a URL
    function isInsideUrl(text, pos) {
        // Look backwards for URL patterns
        const lookBehind = text.substring(Math.max(0, pos - 100), pos);

        // Check for common URL protocols
        const urlPatterns = [
            /https?:\/\/[^\s]*$/,
            /ftp:\/\/[^\s]*$/,
            /www\.[^\s]*$/,
        ];

        for (const pattern of urlPatterns) {
            if (pattern.test(lookBehind)) {
                return true;
            }
        }

        // Check if we're inside markdown link syntax [text](url)
        // Look for an opening parenthesis before current position and closing after
        let parenDepth = 0;
        for (let i = pos - 1; i >= 0; i--) {
            if (lookBehind[lookBehind.length - (pos - i)] === ')') {
                parenDepth++;
            } else if (lookBehind[lookBehind.length - (pos - i)] === '(') {
                if (parenDepth === 0) {
                    // We found an opening paren, check if it's part of a link [...](...
                    if (i > 0 && text[i - 1] === ']') {
                        return true;
                    }
                    break;
                }
                parenDepth--;
            }
        }

        return false;
    }

    // Helper function to create inline rules for standard decorations
    function createInlineRule(name, marker, tag, allowDouble = true, skipInUrls = false) {
        const singleChar = marker;
        const doubleChar = marker + marker;

        // Single character rule (no spaces): /word/
        md.inline.ruler.before('emphasis', `${name}_single`, function (state, silent) {
            if (name === 'italic_slash') console.log(`[DEBUG] italic_slash check at ${state.pos}: ${state.src.slice(state.pos, state.pos + 10)}`);

            const start = state.pos;
            const max = state.posMax;

            // Check if we're at the marker
            if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {
                return false;
            }

            // Skip if inside URL (for markers like /)
            if (skipInUrls && isInsideUrl(state.src, start)) {
                return false;
            }

            // Don't match if preceded by alphanumeric (to avoid conflicts in middle of words)
            if (start > 0) {
                const prevChar = state.src.charCodeAt(start - 1);
                if ((prevChar >= 0x30 && prevChar <= 0x39) || // 0-9
                    (prevChar >= 0x41 && prevChar <= 0x5A) || // A-Z
                    (prevChar >= 0x61 && prevChar <= 0x7A)) { // a-z
                    return false;
                }
            }

            // Check if next character is a space - if so, don't match single character version
            if (start + 1 < max && state.src.charCodeAt(start + 1) === 0x20) {
                return false;
            }

            // Find closing marker
            let pos = start + 1;
            let foundClose = false;

            while (pos < max) {
                if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {
                    // Found potential closing marker
                    // Make sure it's not followed by the same marker (double)
                    if (pos + 1 < max && state.src.charCodeAt(pos + 1) === marker.charCodeAt(0)) {
                        pos += 2;
                        continue;
                    }
                    // Make sure closing marker is not preceded by space
                    if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 0x20) {
                        pos++;
                        continue;
                    }
                    foundClose = true;
                    break;
                }
                pos++;
            }

            if (!foundClose || pos === start + 1) {
                return false;
            }

            if (!silent) {
                const token_o = state.push(`${tag}_open`, tag, 1);
                token_o.markup = singleChar;

                const token_t = state.push('text', '', 0);
                token_t.content = state.src.slice(start + 1, pos);

                const token_c = state.push(`${tag}_close`, tag, -1);
                token_c.markup = singleChar;
            }

            state.pos = pos + 1;
            return true;
        });

        // Double character rule (with spaces): // word //
        if (allowDouble) {
            md.inline.ruler.before('emphasis', `${name}_double`, function (state, silent) {
                const start = state.pos;
                const max = state.posMax;

                // Check if we're at double marker
                if (start + 1 >= max ||
                    state.src.charCodeAt(start) !== marker.charCodeAt(0) ||
                    state.src.charCodeAt(start + 1) !== marker.charCodeAt(0)) {
                    return false;
                }

                // Must have space after opening marker
                if (start + 2 >= max || state.src.charCodeAt(start + 2) !== 0x20) {
                    return false;
                }

                // Find closing marker (space + double marker)
                let pos = start + 3;
                let foundClose = false;

                while (pos + 2 < max) {
                    if (state.src.charCodeAt(pos) === 0x20 &&
                        state.src.charCodeAt(pos + 1) === marker.charCodeAt(0) &&
                        state.src.charCodeAt(pos + 2) === marker.charCodeAt(0)) {
                        foundClose = true;
                        break;
                    }
                    pos++;
                }

                if (!foundClose) {
                    return false;
                }

                if (!silent) {
                    const token_o = state.push(`${tag}_open`, tag, 1);
                    token_o.markup = doubleChar;

                    const token_t = state.push('text', '', 0);
                    token_t.content = state.src.slice(start + 3, pos);

                    const token_c = state.push(`${tag}_close`, tag, -1);
                    token_c.markup = doubleChar;
                }

                state.pos = pos + 3;
                return true;
            });
        }
    }

    // Special function for superscript/subscript that allows mid-word usage
    function createScriptRule(name, marker, tag) {
        md.inline.ruler.before('emphasis', name, function (state, silent) {
            const start = state.pos;
            const max = state.posMax;

            // Check if we're at the marker
            if (state.src.charCodeAt(start) !== marker.charCodeAt(0)) {
                return false;
            }

            // Check if next character is a space - if so, don't match
            if (start + 1 < max && state.src.charCodeAt(start + 1) === 0x20) {
                return false;
            }

            // Find closing marker
            let pos = start + 1;
            let foundClose = false;

            while (pos < max) {
                if (state.src.charCodeAt(pos) === marker.charCodeAt(0)) {
                    // Found closing marker
                    // Make sure closing marker is not preceded by space
                    if (pos > start + 1 && state.src.charCodeAt(pos - 1) === 0x20) {
                        pos++;
                        continue;
                    }
                    foundClose = true;
                    break;
                }
                pos++;
            }

            if (!foundClose || pos === start + 1) {
                return false;
            }

            if (!silent) {
                const token_o = state.push(`${tag}_open`, tag, 1);
                token_o.markup = marker;

                const token_t = state.push('text', '', 0);
                token_t.content = state.src.slice(start + 1, pos);

                const token_c = state.push(`${tag}_close`, tag, -1);
                token_c.markup = marker;
            }

            state.pos = pos + 1;
            return true;
        });
    }

    // Register all custom syntax rules
    // Bold and Italic (core formatting)
    createInlineRule('bold', '*', 'strong');
    createInlineRule('italic_slash', '/', 'em', true, true); // skipInUrls = true

    // Other decorations
    createInlineRule('underline', '_', 'u');
    createInlineRule('highlight', '=', 'mark');
    createInlineRule('strikethrough', '-', 's');
    createScriptRule('superscript', '^', 'sup');
    createScriptRule('subscript', '~', 'sub');
}

function markdownCheckboxes(md) {
    // 1. Block Rule: Enable "[ ] Text" as a top-level list item
    md.block.ruler.before('list', 'checkbox_block', (state, startLine, endLine, silent) => {
        const pos = state.bMarks[startLine] + state.tShift[startLine];
        const max = state.eMarks[startLine];
        const lineText = state.src.slice(pos, max);

        // Regex: [x](space)
        const match = lineText.match(/^\[([ xX-])\]\s/);

        if (!match) return false;

        if (silent) return true;

        // Stack to track indentation matches.
        // We start with the root list.
        const indentStack = [state.sCount[startLine]];

        state.push('bullet_list_open', 'ul', 1);

        let nextLine = startLine;

        while (nextLine < endLine) {
            const linePos = state.bMarks[nextLine] + state.tShift[nextLine];
            const lineMax = state.eMarks[nextLine];
            const currentLine = state.src.slice(linePos, lineMax);
            const currentIndent = state.sCount[nextLine];

            // Note: If indentation is corrupt (less than root), loop should have handled it in lookahead or breaks here
            if (currentIndent < indentStack[0]) break;

            const itemMatch = currentLine.match(/^\[([ xX-])\]\s/);
            if (!itemMatch) break;

            // 1. Open Item
            const tokenLi = state.push('list_item_open', 'li', 1);
            tokenLi.map = [nextLine, nextLine + 1];
            tokenLi.markup = itemMatch[0].trim();

            // 2. Content
            state.push('paragraph_open', 'p', 1);
            const tokenInline = state.push('inline', '', 0);
            tokenInline.content = currentLine;
            tokenInline.map = [nextLine, nextLine + 1];
            tokenInline.children = [];
            state.push('paragraph_close', 'p', -1);

            // 3. Lookahead logic
            let nextIndent = -1;
            let isNextList = false;

            if (nextLine + 1 < endLine) {
                // Check next line content
                // We use sCount but we must verify it is actually a list item line
                // Otherwise it might be lazy text?
                const nextPos = state.bMarks[nextLine + 1] + state.tShift[nextLine + 1];
                const nextMax = state.eMarks[nextLine + 1];
                const nextStr = state.src.slice(nextPos, nextMax);

                // If line is empty, skip? No, strict list.
                // Note: sCount gives indent.
                nextIndent = state.sCount[nextLine + 1];
                const nextMatch = nextStr.match(/^\[([ xX-])\]\s/);
                if (nextMatch) {
                    isNextList = true;
                }
            }

            if (isNextList && nextIndent > currentIndent) {
                // Next is Child -> Open Nested List
                state.push('bullet_list_open', 'ul', 1);
                indentStack.push(nextIndent);
                // DO NOT CLOSE LI
            } else {
                // Next is Sibling or Ancestor or non-list -> Close LI
                state.push('list_item_close', 'li', -1);

                if (isNextList && nextIndent < currentIndent) {
                    // Pop stack until we find match
                    // This handles closing nested lists AND their parent LIs
                    while (indentStack.length > 1 && nextIndent < indentStack[indentStack.length - 1]) {
                        state.push('bullet_list_close', 'ul', -1);
                        indentStack.pop();
                        // Logic: If we closed a nested list, we are now back in the scope of the Parent LI.
                        // But that Parent LI is effectively "done" with its content + children.
                        // So we must close it too.
                        state.push('list_item_close', 'li', -1);
                    }

                    // Edge case: nextIndent mismatches stack?
                    // We treat it as matching the nearest valid parent (standard markdown flex)
                }
            }

            nextLine++;
        }

        // Final Cleanup: Close remaining open lists
        while (indentStack.length > 0) {
            state.push('bullet_list_close', 'ul', -1);
            indentStack.pop();
            // If we popped a nested list, close its parent LI
            // Exception: The very last UL (Root) does NOT have a parent LI to close here 
            // because strict loop structure separates them.
            // Wait.
            // If stack [Root, Child].
            // We close Child UL. Then Child LI must be closed?
            // See lookahead logic: We closed Child LI inside the loop! 
            // "Else -> Close LI".
            // So last item LI is always closed.
            // So we only close PARENT LIs if we have nested open.

            // Correction:
            // In lookahead, if nextIndent > current, we LEFT LI OPEN.
            // So for every item remaining in stack (except root), there is an OPEN LI waiting.
            if (indentStack.length > 0) {
                state.push('list_item_close', 'li', -1);
            }
        }

        state.line = nextLine;
        return true;
    });

    // 2. Core Rule: Convert "[ ] Text" in list items to <input>
    md.core.ruler.push('checkbox_list', (state) => {
        const tokens = state.tokens;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].type !== 'inline') continue;

            let parentToken = null;
            let foundParent = false;

            if (tokens[i - 1] && tokens[i - 1].type === 'list_item_open') {
                parentToken = tokens[i - 1];
                foundParent = true;
            }
            else if (tokens[i - 2] && tokens[i - 2].type === 'list_item_open' && tokens[i - 1].type === 'paragraph_open') {
                parentToken = tokens[i - 2];
                foundParent = true;
            }

            if (foundParent) {
                const token = tokens[i];
                const text = token.content;
                const pattern = /^\s*\[([ xX-])\]\s+/;
                const match = text.match(pattern);

                if (match) {
                    const checkboxChar = match[1].toLowerCase();
                    const isChecked = checkboxChar === 'x';
                    const isIndeterminate = checkboxChar === '-';

                    const line = parentToken.map ? parentToken.map[0] : 0;

                    parentToken.attrJoin('class', 'task-list-item');
                    if (isChecked) parentToken.attrJoin('class', 'checked');
                    if (isIndeterminate) parentToken.attrJoin('class', 'indeterminate');

                    token.content = text.slice(match[0].length);

                    if (token.children && token.children.length > 0 && token.children[0].type === 'text') {
                        const childText = token.children[0].content;
                        const childMatch = childText.match(pattern);
                        if (childMatch) {
                            token.children[0].content = childText.slice(childMatch[0].length);
                        }
                    }

                    const checkbox = new state.Token('html_inline', '', 0);
                    let checkedAttr = isChecked ? 'checked' : '';
                    let indeterminateAttr = isIndeterminate ? 'data-indeterminate="true"' : '';

                    checkbox.content = `<input type="checkbox" class="task-list-item-checkbox" ${checkedAttr} ${indeterminateAttr} data-source-line="${line}" /> `;

                    if (!token.children) token.children = [];
                    token.children.unshift(checkbox);
                }
            }
        }
    });
}

// markdownRadios.js
// Markdownlint plugin to parse radio button lists ( ) and (x)

function markdownRadios(md) {
    md.core.ruler.push('radio_lists', (state) => {
        const tokens = state.tokens;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].type !== 'inline') continue;

            const content = tokens[i].content;
            // Allow ( ) or (x) with optional space after
            const radioRegex = /^(\( \)|\([xX]\))\s*/;

            if (radioRegex.test(content)) {
                // Find parent list item
                // Scan backwards from i to find the closest list_item_open that hasn't been closed
                // Actually, in the flat token stream, the immediate parent of the 'inline' token's paragraph is usually the list item.
                // Structure: list_item_open, paragraph_open, inline, paragraph_close, list_item_close

                let parentTokenIdx = -1;
                // Look back specifically for the structure [list_item_open, paragraph_open, inline]
                if (i >= 2 && tokens[i - 1].type === 'paragraph_open' && tokens[i - 2].type === 'list_item_open') {
                    parentTokenIdx = i - 2;
                }

                if (parentTokenIdx !== -1) {
                    const match = content.match(radioRegex);
                    const isChecked = match[1].toLowerCase().includes('x');

                    // Consume the marker from content
                    tokens[i].content = content.slice(match[0].length);

                    // Also strip from the first text child if present
                    if (tokens[i].children && tokens[i].children.length > 0) {
                        const firstChild = tokens[i].children[0];
                        if (firstChild.type === 'text') {
                            // Only slice if it starts with the match
                            // (The inline token content is a concatenation of children)
                            // Sometimes children are splitting syntax. 
                            // But usually the text node starts with the marker.
                            // Let's safe check.
                            if (firstChild.content.startsWith(match[0])) {
                                firstChild.content = firstChild.content.slice(match[0].length);
                            } else {
                                // Fallback: regex search/replace on first text node?
                                // Or just rely on token.content update? 
                                // Markdown-it renderer uses children if present.
                                // It's safer to just set content.
                                // Let's assume standard text node first.
                                firstChild.content = firstChild.content.replace(radioRegex, '');
                            }
                        }
                    }

                    // Create Radio Input Token
                    const radioToken = new state.Token('html_inline', '', 0);
                    // Use interactive attributes
                    // Note: We don't use 'disabled' because we want clicks to bubble to React
                    radioToken.content = `<input type="radio" class="task-list-item-radio" ${isChecked ? 'checked' : ''} data-source-line="${tokens[i].map ? tokens[i].map[0] : ''}">`;

                    // Ensure source line map
                    if (tokens[i].map) {
                        radioToken.content = radioToken.content.replace('data-source-line=""', `data-source-line="${tokens[i].map[0]}"`);
                    }

                    // Prepend input to children
                    if (!tokens[i].children) tokens[i].children = [];
                    tokens[i].children.unshift(radioToken);

                    // Add class to List Item (<li>)
                    tokens[parentTokenIdx].attrJoin('class', 'task-list-item');
                    // Add specific class for radios to help styling if needed
                    tokens[parentTokenIdx].attrJoin('class', 'task-list-item-radio-wrapper');
                }
            }
        }
    });
}

// src/markdownCallouts.js
// Plugin to support custom Callout blocks with indentation-based content.

function markdownCallouts(md) {

    function callout(state, startLine, endLine, silent) {
        // Line processing
        const start = state.bMarks[startLine] + state.tShift[startLine];
        const max = state.eMarks[startLine];
        const lineText = state.src.slice(start, max);

        // Regex for Callout Headers: (!) Title, (#) Title, (:color:) Title
        const simpleRegex = /^(\(!\)|\(\?\)|\(i\)|\(#\))(?:[ \t]+(.*))?$/;
        // Robust Custom Regex: Allow spaces inside parens e.g. ( :red: )
        const customRegex = /^\(\s*:\s*([a-zA-Z0-9#]+)\s*:\s*\)(?:[ \t]+(.*))?$/;

        let type = '';
        let title = '';
        let color = '';

        let match = lineText.match(simpleRegex);
        if (match) {
            const marker = match[1];
            if (marker === '(!)') { type = 'warning'; title = 'Warning'; color = '#ff5f56'; }
            else if (marker === '(?)') { type = 'question'; title = 'Question'; color = '#febc2e'; }
            else if (marker === '(i)') { type = 'info'; title = 'Info'; color = '#28c7fa'; }
            else if (marker === '(#)') { type = 'default'; title = 'Note'; color = '#888888'; }

            if (match[2]) title = match[2];
        } else {
            match = lineText.match(customRegex);
            if (match) {
                type = 'custom';
                color = match[1];
                title = match[2] || 'Note';
            }
        }

        if (!type) return false;
        if (silent) return true;

        // Determine Body Range
        const nextLine = startLine + 1;
        let lastLine = startLine;

        // We look for lines indented MORE than the start line
        // NOTE: state.sCount[startLine] includes the initial indent of the header line itself
        // e.g. if header is at 0 indent, body must be > 0.
        // If header is inside a list (indent 2), body must be > 2.

        const threshold = state.sCount[startLine];

        for (let next = nextLine; next < endLine; next++) {
            if (state.isEmpty(next)) continue;

            if (state.sCount[next] > threshold) {
                lastLine = next;
            } else {
                break;
            }
        }

        // Generate Container Token
        const tokenOpen = state.push('callout_open', 'div', 1);
        tokenOpen.attrs = [['class', `callout callout-${type}`]];
        tokenOpen.map = [startLine, lastLine + 1];
        tokenOpen.attrs.push(['style', `--callout-color: ${color};`]);

        // Generate Header
        const tokenHeader = state.push('callout_header_open', 'div', 1);
        tokenHeader.attrs = [['class', 'callout-header']];

        const tokenTitle = state.push('inline', '', 0);
        tokenTitle.content = title;
        tokenTitle.children = [];

        state.push('callout_header_close', 'div', -1);

        // Body Parsing with Indentation Strip
        // Problem: If user indents by 4 spaces, default tokenizer sees "Code Block".
        // Solution: We must "shift" the parser view so it sees 0 indentation for the body lines.
        // We temporarily modify state.sCount and state.blkIndent.

        if (lastLine > startLine) {
            const oldParentType = state.parentType;
            const oldBlkIndent = state.blkIndent;

            // Calculate how much to strip. 
            // Often we strip 'threshold + 1' or just 'threshold' if we want tight packing?
            // Usually, standard indented blocks strip relative to parent.
            // Let's sweep and shift sCount.
            // But we must restore them!
            const oldSCounts = [];

            // We want the "visual indent" of the body to be effectively 0 relative to the block.
            // Find the minimum indent of the body lines?
            // Or just strip 'threshold + N'?
            // Usually, user indents by Tab (4) or 2 spaces.
            // Let's assume we strip ALL common indentation?
            // Or just strip `threshold`. 
            // If header is at 0, and body at 4. We strip 0? No, we need to strip 4 to make it a paragraph.
            // If we strip 4, sCount becomes 0. Paragraph.

            // Find minimum indent of non-empty lines in body
            let minIndent = Infinity;
            for (let i = startLine + 1; i <= lastLine; i++) {
                if (!state.isEmpty(i)) {
                    if (state.sCount[i] < minIndent) minIndent = state.sCount[i];
                }
            }

            // Strip `minIndent` from all lines
            for (let i = startLine + 1; i <= lastLine; i++) {
                oldSCounts[i] = state.sCount[i];
                if (state.sCount[i] >= minIndent) {
                    state.sCount[i] -= minIndent;
                } else {
                    state.sCount[i] = 0;
                }
            }

            state.parentType = 'callout';
            state.blkIndent = 0; // Reset block indent expectation for inner content?

            state.md.block.tokenize(state, startLine + 1, lastLine + 1);

            // Restore
            state.parentType = oldParentType;
            state.blkIndent = oldBlkIndent;
            for (let i = startLine + 1; i <= lastLine; i++) {
                state.sCount[i] = oldSCounts[i];
            }
        }

        state.push('callout_close', 'div', -1);

        state.line = lastLine + 1;
        return true;
    }

    md.block.ruler.before('fence', 'callout', callout, {
        alt: ['paragraph', 'reference', 'blockquote', 'list']
    });
}

function markdownToggles(md) {
    // Core Rule: Identify list items with children and inject toggles
    md.core.ruler.push('list_toggles', (state) => {
        const tokens = state.tokens;
        const collapsedLines = state.env.collapsedLines || new Set();

        // simple stack: { tokenIndex: number, hasChild: boolean }
        const stack = [];

        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];

            if (token.type === 'list_item_open') {
                stack.push({ index: i, hasChild: false });
            }
            else if (token.type === 'list_item_close') {
                if (stack.length > 0) {
                    const item = stack.pop();
                    if (item.hasChild) {
                        // Mark the opening token
                        const openToken = tokens[item.index];
                        openToken.attrJoin('class', 'has-children');

                        // Check if collapsed
                        // Use map[0] (start line) as identifier
                        if (openToken.map && collapsedLines.has(openToken.map[0])) {
                            openToken.attrJoin('class', 'collapsed');
                        }

                        // Inject Toggle Button
                        // We need to inject it into the CONTENT of the list item.
                        // The next tokens are usually `paragraph_open`, `inline`...
                        // If we inject a separate token before paragraph, it renders inside LI but before P.
                        // That works.

                        const toggleToken = new state.Token('html_inline', '', 0);
                        const line = openToken.map ? openToken.map[0] : -1;
                        toggleToken.content = `<span class="list-toggle" data-line="${line}"></span>`;

                        // Insert after openToken
                        // We can't splice safely while iterating? 
                        // Actually we can, but logic gets complex with indices.
                        // Better: Prepend to the children of the first inline token? 
                        // Or insert a simpler token?

                        // Let's modify the stream?
                        // "tokens.splice" is expensive O(N).
                        // Alternative: Add it to the 'inline' token children.

                        // Find the first inline token inside this LI
                        let j = item.index + 1;
                        while (j < i && tokens[j].type !== 'inline') {
                            j++;
                        }

                        if (j < i) {
                            // Found inline token (content of the LI)
                            const inlineToken = tokens[j];
                            if (!inlineToken.children) inlineToken.children = [];

                            // Create inline token for the toggle
                            const toggleNode = new state.Token('html_inline', '', 0);
                            toggleNode.content = `<span class="list-toggle" data-line="${line}"></span>`;

                            // Prepend
                            inlineToken.children.unshift(toggleNode);
                        }
                    }
                }
            }
            else if (token.type === 'bullet_list_open' || token.type === 'ordered_list_open') {
                // If we are inside an LI, marks it as having a child
                if (stack.length > 0) {
                    stack[stack.length - 1].hasChild = true;
                }
            }
        }
    });
}

// Wikilinks Plugin for markdown-it
// Implements Obsidian-style [[wikilink]] syntax
// Supports: [[Note]], [[Note#heading]], [[Note^block-id]], [[Note|Display Text]]

function markdownWikilinks(md, options = {}) {
    // Parse wikilink syntax and extract components
    function parseWikilink(text) {
        // Pattern: [[target|display]] or [[target#heading]] or [[target^block]] or [[target]]
        const result = {
            target: '',
            heading: null,
            blockId: null,
            display: null
        };

        // Check for display text separator |
        const pipeIndex = text.indexOf('|');
        let targetPart = text;

        if (pipeIndex !== -1) {
            targetPart = text.substring(0, pipeIndex);
            result.display = text.substring(pipeIndex + 1).trim();
        }

        // Check for heading anchor #
        const hashIndex = targetPart.indexOf('#');
        if (hashIndex !== -1) {
            result.target = targetPart.substring(0, hashIndex).trim();
            result.heading = targetPart.substring(hashIndex + 1).trim();
            return result;
        }

        // Check for block anchor ^
        const caretIndex = targetPart.indexOf('^');
        if (caretIndex !== -1) {
            result.target = targetPart.substring(0, caretIndex).trim();
            result.blockId = targetPart.substring(caretIndex + 1).trim();
            return result;
        }

        // Just a simple target
        result.target = targetPart.trim();
        return result;
    }

    // Inline rule to detect [[...]] patterns
    md.inline.ruler.before('emphasis', 'wikilink', function (state, silent) {
        const start = state.pos;
        const max = state.posMax;

        // Check if we're at [[
        if (start + 2 >= max ||
            state.src.charCodeAt(start) !== 0x5B || // [
            state.src.charCodeAt(start + 1) !== 0x5B) { // [
            return false;
        }

        // Find closing ]]
        let pos = start + 2;
        let foundClose = false;

        while (pos + 1 < max) {
            if (state.src.charCodeAt(pos) === 0x5D && // ]
                state.src.charCodeAt(pos + 1) === 0x5D) { // ]
                foundClose = true;
                break;
            }
            pos++;
        }

        if (!foundClose) {
            return false;
        }

        // Extract content between [[ and ]]
        const content = state.src.slice(start + 2, pos);

        // Don't match empty wikilinks
        if (content.trim().length === 0) {
            return false;
        }

        if (!silent) {
            const parsed = parseWikilink(content);

            // Create link token
            const token_o = state.push('link_open', 'a', 1);
            token_o.attrSet('class', 'wikilink');
            token_o.attrSet('href', '#'); // Placeholder, developers should override click behavior

            // Add data attributes for developer use
            if (parsed.target) {
                token_o.attrSet('data-target', parsed.target);
            }
            if (parsed.heading) {
                token_o.attrSet('data-heading', parsed.heading);
            }
            if (parsed.blockId) {
                token_o.attrSet('data-block', parsed.blockId);
            }

            // Text content
            const token_t = state.push('text', '', 0);
            token_t.content = parsed.display || content;

            // Close link
            state.push('link_close', 'a', -1);
        }

        state.pos = pos + 2; // Move past ]]
        return true;
    });
}

// Block IDs Plugin for markdown-it
// Implements Obsidian-style block identifiers: ^block-id at end of lines
// Adds id attributes to rendered HTML blocks for direct linking

function markdownBlockIds(md) {
    // Core rule to process block IDs
    md.core.ruler.push('block_ids', (state) => {
        const tokens = state.tokens;

        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];

            // Only process inline tokens (text content)
            if (token.type !== 'inline' || !token.content) {
                continue;
            }

            // Check for block ID pattern at end of line: ^block-id
            // Pattern: space + ^ + alphanumeric/dash/underscore id
            const blockIdPattern = /\s\^([\w-]+)\s*$/;
            const match = token.content.match(blockIdPattern);

            if (match) {
                const blockId = match[1];

                // Remove the block ID from visible content
                token.content = token.content.replace(blockIdPattern, '');

                // Update children if they exist
                if (token.children && token.children.length > 0) {
                    const lastChild = token.children[token.children.length - 1];
                    if (lastChild.type === 'text') {
                        lastChild.content = lastChild.content.replace(blockIdPattern, '');
                    }
                }

                // Find the parent block token (paragraph, list item, heading, etc.)
                let parentToken = null;

                // Look backwards for opening block token
                for (let j = i - 1; j >= 0; j--) {
                    const prev = tokens[j];
                    if (prev.type.endsWith('_open') && prev.nesting === 1) {
                        parentToken = prev;
                        break;
                    }
                }

                // Add id attribute to parent block
                if (parentToken) {
                    parentToken.attrSet('id', blockId);
                }
            }
        }
    });
}

// Utility functions for wikilinks and block IDs
// These are helper functions for developers integrating better-markdown

/**
 * Extract all wikilinks from markdown text
 * @param {string} markdown - The markdown text to parse
 * @returns {Array} Array of wikilink objects with target, heading, blockId, display properties
 */
function extractWikilinks(markdown) {
    const wikilinks = [];
    const pattern = /\[\[([^\]]+)\]\]/g;
    let match;

    while ((match = pattern.exec(markdown)) !== null) {
        const content = match[1];
        const wikilink = {
            raw: match[0],
            target: '',
            heading: null,
            blockId: null,
            display: null
        };

        // Check for display text separator |
        const pipeIndex = content.indexOf('|');
        let targetPart = content;

        if (pipeIndex !== -1) {
            targetPart = content.substring(0, pipeIndex);
            wikilink.display = content.substring(pipeIndex + 1).trim();
        }

        // Check for heading anchor #
        const hashIndex = targetPart.indexOf('#');
        if (hashIndex !== -1) {
            wikilink.target = targetPart.substring(0, hashIndex).trim();
            wikilink.heading = targetPart.substring(hashIndex + 1).trim();
            wikilinks.push(wikilink);
            continue;
        }

        // Check for block anchor ^
        const caretIndex = targetPart.indexOf('^');
        if (caretIndex !== -1) {
            wikilink.target = targetPart.substring(0, caretIndex).trim();
            wikilink.blockId = targetPart.substring(caretIndex + 1).trim();
            wikilinks.push(wikilink);
            continue;
        }

        // Just a simple target
        wikilink.target = targetPart.trim();
        wikilinks.push(wikilink);
    }

    return wikilinks;
}

/**
 * Extract all block IDs from markdown text
 * @param {string} markdown - The markdown text to parse
 * @returns {Array} Array of block ID strings
 */
function extractBlockIds(markdown) {
    const blockIds = [];
    const pattern = /\s\^([\w-]+)\s*$/gm;
    let match;

    while ((match = pattern.exec(markdown)) !== null) {
        blockIds.push(match[1]);
    }

    return blockIds;
}

/**
 * Generate a unique block ID
 * This is a simple timestamp-based implementation
 * Developers can override this with their own strategy
 * @returns {string} A unique block ID
 */
function generateBlockId() {
    const timestamp = Date.now().toString(36); // Base36 for shorter strings
    const random = Math.random().toString(36).substring(2, 5); // 3 random chars
    return `block-${timestamp}-${random}`;
}

var wikilinkUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    extractBlockIds: extractBlockIds,
    extractWikilinks: extractWikilinks,
    generateBlockId: generateBlockId
});

// Main entry point for better-markdown library
// Export all markdown-it plugins for use in any editor (CodeMirror, Monaco, etc.)


/**
 * Convenience function to apply all plugins to a markdown-it instance
 * @param {MarkdownIt} md - The markdown-it instance
 * @returns {MarkdownIt} The same instance with all plugins applied
 * 
 * @example
 * import MarkdownIt from 'markdown-it';
 * import { applyAllPlugins } from 'better-markdown';
 * 
 * const md = new MarkdownIt();
 * applyAllPlugins(md);
 */
function applyAllPlugins(md) {
    md.use(customSyntaxPlugin);
    md.use(markdownCheckboxes);
    md.use(markdownRadios);
    md.use(markdownCallouts);
    md.use(markdownToggles);
    md.use(markdownWikilinks);
    md.use(markdownBlockIds);
    return md;
}

// Default export with all plugins and utilities
var index = {
    customSyntaxPlugin,
    markdownCheckboxes,
    markdownRadios,
    markdownCallouts,
    markdownToggles,
    markdownWikilinks,
    markdownBlockIds,
    wikilinkUtils,
    applyAllPlugins
};

export { applyAllPlugins, customSyntaxPlugin, index as default, markdownBlockIds, markdownCallouts, markdownCheckboxes, markdownRadios, markdownToggles, markdownWikilinks, wikilinkUtils };
//# sourceMappingURL=index.js.map
